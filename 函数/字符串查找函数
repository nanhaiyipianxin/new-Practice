char* bianli(char* src, char* dest)
{
	char* z = src;		//遍历用的
	char* w = src;		//存储记录每次比对首地址
	char* tdest = dest;//指向字符串，为啥不用dest？因为要回滚

	while (*z)         //循环src
	{
			while (*z==*tdest &&*z!='\0')//如果两个字符相同为真，然后往下;不为真的时候就停了，并且z不等于\0
			{								//因为如果字符在结尾相同那么两个值最后全相等了\0也相等,然后又自增一次
				z++;						//直接偏移到0后了，tdest检测不到
				tdest++;
			}
		if (*tdest == '\0')return w;//如果上面的循环最后一次自增后，*tdest到了最后的位置，就用w返回首地址
		
		tdest = dest;       //让dest重新赋予tdest值，回到首字符的地址

		z = w;				//让已经被改变的遍历地址，回到上次记录被比对的地址
		z++;				//这个是为了不从被比对地址开始，从比对地址下一个开始
		w = z	;		           //这个是将w的值记录
	}
	return;
}

使用方法
